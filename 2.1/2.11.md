### Упражнение 2.11.
Во многих решениях этой задачи, найденных в интернете, предлагается рассматривать девять случаев в соответствии с двумя независимыми значениями функции знака: $sign(x_1 x_2)$ и $sign(y_1 y_2)$, где $(x_1, x_2), (y_1, y_2)$ &mdash; умножаемые интервалы, 
```math
sign(x) = 
    \begin{cases}
        1, & x > 0\\
        0, & x = 0\\
        -1, & x < 0
    \end{cases}.
```
Однако, используя разбиение на такие случаи, невозможно реализовать процедуру $\texttt{mul-interval}$ таким образом, чтобы только в одном случае требовалось более двух умножений. Покажем это.

Для этого рассмотрим два примера:

1. Рассмотрим случай, когда $sign(x_1 x_2) = sign(y_1 y_2) = -1$. В этом случае требуется хотя бы три умножения:
```math
(-1000, 1) \cdot (-1000, 2) = (x_1 y_2, \, x_1 y_1) = (-2000, 1000000),
```
```math
(-10, 10) \cdot (-10, 100) =  (x_1 y_2, \, x_2 y_2) = (-1000, 1000),
```
```math
(-1, 1) \cdot (-2, 1) = (x_2 y_1,\, x_1 y_1) = (-2, 2).
```

2. Теперь рассмотрим случай, когда $sign(x_1 x_2) = {sign(y_1 y_2)} = 1$. В этом случае так же требуется хотя бы три умножения:
```math
(-10, -2) \cdot (-100, -3) = (x_2 y_2,\, x_1 y_1) = (6, 1000),
```
```math
(-10, -2) \cdot (2, 10) = (x1 y2,\, x2 y1) = (-100, -4),
```
```math
(1, 2) \cdot (2, 3) = (x_1 y_1, x_2 y_2) = (2, 6).
```

Этими двумя примерами мы показали, что по крайней мере в двух случаях из разбиения требуется более двух умножений, а, значит, нельзя реализовать процедуру $\texttt{mul-interval}$, таким образом используя функцию знака.

[Здесь приведён код возможной реализации процедуры $\texttt{mul-interval}$](/src/chapter2/11.rkt), где используется разбиение на шесть случаев, из которых только в одном требуется более двух умножений (а именно четыре). Идея заключается в том, чтобы использовать упрощённую функцию знака $sign$:
```math
sign(x) = 
    \begin{cases}
        1, & x \geqslant 0\\
        -1, & x < 0
    \end{cases},
```
и различать случаи по значению этой функции на $x_1, x_2, y_1, y_2$ (несмотря на то, что всего существует $2^4 = 16$, возможны только $9$: $sign(x_2)$ не может быть равен $-1$, если $sign(x_1) = 1$, и в то же время $sign(x_1)$ не может быть равен $1$, если $sign(x_2) = -1$). Вторая хитрость заключается в модификации процедуры $\texttt{make-interval}$, которую мы провели ещё в [упражнении 2.7](/2.1/2.07.rkt):
```scheme
(define (make-interval a b) 
    (if (< a b)
        (cons a b)
        (cons b a)))
```
То есть любой интервал при определении будет «развёрнут» правильным образом: $x_1 \leqslant x_2$. Это даёт нам возможность объединять в один случаи, равные в точности до перестановки координат. Это «симметричные» случаи, например, 
```math
\left( sign(x_1), sign(x_2), sign(y_1), sign(y_2) \right) = (-1, -1,\, -1,\;\;\, 1),
```
```math
\left( sign(x_1), sign(x_2), sign(y_1), sign(y_2) \right) = (-1,\;\;\, 1,\, -1,\, -1).
```
Такой метод позволяет нам «склеить» три пары случаев и в результате рассматривать $6$ случаев вместо $9$, что, конечно, делает код более читаемым, но всё ещё оставляет его довольно запутанным.

[Менее радикальный метод (но оттого и менее эффективный) представлен здесь.](/src/chapter2/11-modest.rkt) Его идея заключается в том, что если $sign(x_1x_2) + sign(y_1y_2) \leqslant 0$, где $sign$ &mdash; классическая функция знака, то мы можем обойтись всего $4$ умножениями (не считая умножений $x_1x_2$ и $y_1y_2$).
