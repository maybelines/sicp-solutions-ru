### Упражнение 1.5. 
В языках программирования существуют два основных порядка вычисления выражений:
	
* *Строгие вычисления* (ещё называют аплликативным порядком вычисления)
* *Нестрогие вычисления* (представитель &mdash; нормальный порядок вычислений)
	
При строгих вычислениях (аппликативном порядке) сначала полностью вычисляются аргументы функции, затем функция применяется. Такой порядок вычислений используется в большинстве языков программирования.
	
При нестрогих вычислениях функция может возвращать результат до того, как все вычисления аргументов произведены. Так, при нормальном порядке вычислений ни один из аргументов функции не вычисляется до того, как его значение не потребуется в теле функции.
	
Теперь рассмотрим процедуру, «проверяющую» порядок вычислений интерпретатора:

```scheme
(define (p) (p)) 

(define (test x y)
    (if (= x 0) 
        0 
        y))  

(test 0 (p))
```

Если интерпретатор работает с аппликативным порядком вычислений, то при вызове процедуры $\texttt{(test 0 (p))}$ в первую очередь будут вычисляться аргументы, то есть интерпретатор обратится к определению процедуры $\texttt{(define (p) (p))}$, которая является бесконечным циклом (см. замечание, п.1). Таким образом, при аппликативном порядке вычислений этот код будет исполняться вечно.
	
Если же интерпретатор работает с нормальным порядком вычислений, то при вызове процедуры $\texttt{(test 0 (p))}$ в первую очередь интерпретатор обратится к определению процедуры $\texttt{test}$ и сразу же попадет в случай x = 0, то есть интерпретор «досрочно» выведет 0.
	
**Замечание.** 
1. На стр. 13 есть комментарий к подстановочной модели применения процедуры, раскрывающий проблему аппликативного порядка вычислений в нашем случае: 
> Проблема возникает из-за возможности смешения имен, которые используются как формальные параметры процедуры, с именами (возможно, с ними совпадающими), которые используются в выражениях, к которым процедура может применяться.
	
2. Интерпретатор Racket, использующий аппликативный порядок вычисления, выполняет приведённый выше код бесконечно.