### Упражнение 1.26.
Рассмотрим процедуру, предложенную в упражнении:
```scheme
(define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp) 
           (remainder (* (expmod base (/ exp 2) m) 
                         (expmod base (/ exp 2) m)) 
                      m)) 
          (else (remainder (* base 
                              (expmod base (- exp 1) m)) 
                           m))))
```
Действительно, при таком изменении процедуры $\texttt{expmod}$ процесс порядка $Θ(\log n)$ (теоретически такого порядка, см. [упражнение 1.24](./1.24.md)) превращается в процесс порядка $Θ(n)$, где $n$ &mdash; показатель степени, то есть $\texttt{exp}$.

Дело в том, что модифицируя процедуру таким образом, мы меняем порождаемый процесс с логарифмически рекурсивного на древовидно-рекурсивный. Такой процесс можно проиллюстрировать деревом, число вершин которого и есть число шагов. 

Пусть $T(n)$ &mdash; число шагов алгоритма, тогда нетрудно видеть, что 
```math
T(0) = 0, \;\, T(2k + 1) = T(2k) + 1,
``` 
```math
T(2k) = 2T(k) + 2, \;\, k \in \mathbb{N}_0.
```
Из этих соотношений понятно, что при фиксированном числе двоичных разрядов, $T(n)$ примет максимальное значение на том числе, у которого в двоичном разложении будут одни единицы. Пусть $n$ &mdash; именно такое число, тогда:
```math
T(n) = T(n-1) + 1 = 2T(\frac{n-1}{2}) + 2 + 1 = \ldots
```
```math
= 2^{\lfloor \log_2 n \rfloor + 1} T\left( 1 \right) + \underbrace{2 + \ldots + 2}_{\lfloor \log_2 n \rfloor + 1}  + \underbrace{1 + \ldots + 1}_{\lfloor \log_2 n \rfloor + 1}
```
```math
= 2^{\lfloor \log_2 n \rfloor + 1} + 3 \lfloor \log_2 n \rfloor + 3 = Θ(n).
```
Таким образом, мы показали, что временная сложность полученного алгоритма линейна.
