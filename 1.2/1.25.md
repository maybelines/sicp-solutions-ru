### Упражнение 1.25.
Рассмотрим процедуру, предложенную в упражнении:
```scheme
(define (expmod base exp m) 
    (remainder (fast-expt base exp) m))
```
Заметим, что она, в отличие от процедуры $\texttt{expmod}$ из упражнения 1.24, вычисляет остаток не на каждом шагу алгоритма быстрого возведения в степень, а только после окончания возведения в степень. Таким образом, в промежуточных вычислениях появляются достаточно большие числа, элементарные операции над которыми занимают большее время. 

Сравним время выполнения алгоритма с новой версией процедуры $\texttt{expmod}$. [Реализация изменённого алгоритма](/src/chapter1/25.rkt) работает гораздо медленнее:
```scheme
; average time is 7250 ms, average time with normal expmod is 40 ms
(search-for-primes 1000 1019)
```
Отметим, что число шагов теста Ферма при использовании новой версии процедуры $\texttt{expmod}$ не увеличивается, однако, если числа в промежуточных вычислениях первой версии занимают до $\lceil \log_2 n \rceil$ битов, то в новой версии они занимают до $\lceil \log_2 n^n \rceil = n \lceil \log_2 n \rceil$ битов, причём перед применением процедуры $\texttt{remainder}$ они занимают ровно $n \lceil \log_2 a \rceil$, где $a$ &mdash; случайно выбранное число из теста Ферма ($a \leqslant n-1$).